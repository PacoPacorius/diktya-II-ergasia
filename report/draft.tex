% TODO:
% 1. γιατί join(1000); Πού χρησιμεύει;
\documentclass{article}
\usepackage{polyglossia}
\usepackage{amsmath}
\usepackage{fontspec}
\usepackage{lipsum}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\hypersetup{%
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdfinfo = {%
        Title = CN II VoIP over UDP
        Author = Χρήστος Μάριος Περδίκης, Αιμιλία Παλάσκα
        Producer = XeLaTeX
    }
}

\NewDocumentCommand{\textsrcport}{}{\textit{text\_src\_port} $= 26555$}
\NewDocumentCommand{\textdestport}{}{\textit{text\_dest\_port} $= 26557$}
\NewDocumentCommand{\voicedestport}{}{\textit{voice\_dest\_port} $= 26567$}
\NewDocumentCommand{\voicesrcport}{}{\textit{voice\_src\_port} $= 26565$}

\title{CN\_II Chat and VoIP over UDP 2024}
%\author{\vspace{6pt}Ομάδα ΑΕ\\ 
    %Χρήστος Μάριος Περδίκης 10075 cperdikis@ece.auth.gr
   %\and Αιμιλία Παλάσκα 10453 aimiliapm@ece.auth.gr}
\author{\phantom{hehehe they will never see this coming!}Ομάδα ΑΕ\phantom{hehehe they will never see this coming!} \and 
    Χρήστος Μάριος Περδίκης 10075 cperdikis@ece.auth.gr
   \and Αιμιλία Παλάσκα 10453 aimiliapm@ece.auth.gr}
\date{}
% αν δεν δουλεύει αυτό το font άλλαξέ το, οποιοδήποτε .otf font με ελληνικούς χαρακτήρες will do
\setmainfont{FreeSerif}

\begin{document}
\maketitle
% περιγραφή κώδικα
% εικόνες ανταλλαγής κειμένου από Wireshark
% voice datagram stream από Wireshark

Το παρόν έγγραφο είναι η αναφορά της εργασίας του μαθήματος Δίκτυα Υπολογιστών 
ΙΙ. Κληθήκαμε να υλοποιήσουμε μια εφαρμογή VoIP και Chat σε Java η οποία θα
χρησιμοποιεί το πρωτόκολλο UDP. Συγκεκριμένα υλοποιήσαμε τον κώδικα αποστολής 
και λήψης πακέτων κειμένου και φωνής. Ακολουθεί η περιγραφή του κώδικα που γράψαμε.

\section{Ανταλλαγή μηνυμάτων κειμένου}
Λαμβάνουμε datagrams κειμένου στη θύρα \textdestport{} και στέλνουμε από τη θύρα 
\textdestport. Το μέγεθος του payload κάθε datagram είναι $1024$ bytes, αλλά όπως θα 
δούμε παρακάτω υποστηρίζουμε να σταλθούν μηνύματα μεγαλύτερου payload.

\subsection{Receive}
Ο μηχανισμός λήψης μηνυμάτων υλοποιείται στην συνάρτηση \textit{receiveText}.
Για να εγγυηθούμε ότι η λήψη πακέτων δεν θα περιορίσει την υπόλοιπη λειτουργικότητα της
εφαρμογής, δηλαδή την αποστολή μηνυμάτων και την δυνατότητα κλήσης, η συνάρτηση αυτή
ανατίθεται σε ένα Thread, το οποίο ξεκινάει από την main και εκτελεί μία αέναη λούπα. 
Μέσα σε αυτήν λαμβάνονται πακέτα ορισμένου μεγέθους (1024 bytes) και εμφανίζονται στην
διεπαφή, έχοντας σαν αρχή το ``Friend:'' για να γίνει αντιληπτό πότε πρόκειται για εισερχόμενο
μήνυμα. Θεωρούμε ότι όλα τα πακέτα θα είναι το πολύ 1024 bytes, διότι η διαδικασία
αποστολής μηνυμάτων διαχειρίζεται τον χωρισμό μεγάλων συμβολοσειρών σε πολλαπλά πακέτα.
Στην διάρκεια των δοκιμών μας δεν παρατηρήθηκε άφιξη των πακέτων με λάθος σειρά, όταν αυτά
προέρχονταν από χωρισμό μεγαλύτερου payload. 

\subsection{Send}
Αρχικά ελέγχουμε αν το \textit{inputTextField} είναι άδειο, στην οποία 
περίπτωση αγνοούμε το πάτημα του κουμπιού Send και δεν στέλνουμε τίποτα. 
Αν δεν είναι άδειο, τότε ξεκινάμε τη διαδικασία αποστολής ενός udp datagram.

Αφότου αποθηκεύσουμε το \textit{input\_text} στη μεταβλητή 
\textit{payload} σε μορφή bytes, υπολογίζουμε πόσες φορές χωράει το
$1024$ στο μήκος του \textit{payload}. Στη γενική περίπτωση, θα σταλθούν σε αριθμό
$\text{\textit{multiplier}} + 1$ datagrams, όπου όλα εκτός του τελευταίου
θα έχουν μέγεθος payload 1024 bytes και το τελευταίο θα έχει μέγεθος payload \textit{modulo}
bytes (\textit{multiplier} είναι το πηλίκο και \textit{modulo} το υπόλοιπο
της διαίρεσης $\text{\textit{payload.length}} / 1024$).

Για παράδειγμα, αν έχουμε ένα μήνυμα σε μέγεθος $2050$ bytes, το 
μήνυμα θα χωριστεί και θα σταλεί με δύο datagrams με payload μήκους $1024$ bytes
και ενός ακόμα datagram με payload μήκους $2050\ \%\ 1024 = 2$ bytes. Αν πάλι στείλουμε
ένα μήνυμα μεγέθους $256$ bytes, θα στείλουμε ένα payload μεγέθους $256$ bytes. Προφανώς
τα τελικά datagrams θα είναι λίγο μεγαλύτερα λόγω της προσθήκης του udp header.

Ουσιαστικά, αν λάβουμε υπόψιν μας και τον κώδικα που λαμβάνει κείμενο, η εφαρμογή μας 
τεμαχίζει τα πολύ μεγάλα κείμενα σε περισσότερα μικρότερα διαδοχικά μηνύματα.

\subsection{Παράδειγμα ανταλλαγής μηνυμάτων μέσω Wireshark}
Ακολουθούν ανταλλαγές μηνυμάτων κειμένου μεταξύ δύο υπολογιστών στο ίδιο δίκτυο 
οι οποίες καταγράφηκαν με το πρόγραμμα Wireshark. Οι διευθύνσεις IPv4 των δύο υπολογιστών
ήταν $192.168.100.22$ και $192.168.100.13$. Στην εικόνα~\ref{text-simple-n-small} βλέπουμε 
την αποστολή ενός μηνύματος με κείμενο ``hohoho''. Εφόσον έχουμε κείμενο μήκους $6$ bytes,
το datagram payload έχει και αυτό μέγεθος $6$ bytes.

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{text-simple-small.png}
    \caption{Καταγραφή μηνύματος μικρού μήκους στο Wireshark}\label{text-simple-n-small}
\end{figure}

Στις εικόνες~\ref{text-big},~\ref{text-big2} και~\ref{text-big-final} στείλαμε τον ίδιο 
τον πηγαίο κώδικα μέσω της εφαρμογής για να 
δοκιμάσουμε τη συμπεριφορά της σε πολύ μεγάλα κείμενα ($> 1024$ bytes). Βλέπουμε ότι το 
κείμενο χωρίζεται σε πολλά datagrams με μέγεθος payload $1024$ bytes μέχρι το τελευταίο
datagram στο οποίο στέλνεται ουσιαστικά.

\begin{figure}%
    \centering
    \subcaptionbox{Πρώτο datagram από πολλά που στάλθηκαν για να στείλουμε τον πηγαίο μας κώδικα!\label{text-big}}
        {\includegraphics[scale=0.1]{textbigsend}}
    \subcaptionbox{Δεύτερο datagram. Όλα μέχρι και το προτελευταίο θα έχουν το ίδιο μήκος!\label{text-big2}}{%
        \includegraphics[scale=0.1]{text-big-send2.png}}
    \subcaptionbox{Τελευταίο datagram, μικρότερο σε μέγεθος από όλα τα προηγούμενα!\label{text-big-final}}{%
        \includegraphics[scale=0.15]{text-big-send-final.png}}
        \caption{Καταγραφή αποστολής πολύ μεγάλου κειμένου με Wireshark}
\end{figure}


\section{VoIP}
\subsection{Receive}
\subsection{Send}
Αντίστοιχα με λήψη και αποστολή κειμένου λαμβάνουμε datagrams φωνής στη θύρα \voicedestport{} και 
στέλνουμε από τη θύρα \voicesrcport. An πατήσουμε το κουμπί Call και δεν βρισκόμαστε σε κλήση, 
εκτός από το thread λήψης πακέτων φωνής, γίνεται εκκίνηση του thread καταγραφής και αποστολής φωνής.
Αν είμαστε ήδη σε κλήση, τότε τα δύο threads τερματίζουν ομαλά και η κλήση τελειώνει. Είναι δυνατόν
η ξαναεπανεκκίνηση της κλήσης αν πατηθεί το κουμπί Call ξανά.

Στο ξεχωριστό thread αναλαμβάνουμε την καταγραφή και την αποστολή ήχου. Με τις κατάλληλες ρυθμίσεις
στον υπολογιστή του χρήστη μπορεί να γίνει καταγραφή φωνής μέσω του μικροφώνου αλλά και καταγραφή των
ήχων του συστήματος όπως π.χ. μουσικής. Αφού αρχικοποιήσουμε το socket και την διεύθυνση του προορισμού,
θέτουμε το AudioFormat μας να είναι 8kHz μονοφωνικό PCM με 8-bits για κάθε sample. Αν είχαμε παραπάνω από 
ένα byte για κάθε sample, η διάταξή μας θα ήταν big endian. 

Ανοίγουμε ένα TargetDataLine με \mbox{\textit{buffer\_size} $= 1024$} και ξεκινάμε την καταγραφή ήχου
σε ένα while loop το οποίο τερματίζει μόνο όταν πατηθεί το κουμπί Call.
Κάθε φορά διαβάζουμε $1024/5 = 204$ bytes από τον εσωτερικό buffer του TargetDataLine, έτσι σιγουρευόμαστε
ότι δεν θα έχουμε ούτε buffer overflows ούτε underflows. Τα δεδομένα ήχου γίνονται append στο 
ByteArrayOutputStream \textit{out}, το οποίο μετατρέπουμε στο byte array \textit{audio\_data} όταν
θέλουμε να τα χρησιμοποιήσουμε.

Όταν το \textit{audio\_data} γεμίσει επαρκώς, τότε στέλνουμε ένα πακέτο. Αυτό γίνεται σειριακά με την
καταγραφή ήχου, στο ίδιο thread. Αν επιθυμούσαμε μικρότερο latency θα μπορούσαμε να είχαμε ξεχωριστά 
threads για την καταγραφή ήχου και την αποστολή πακέτων. Όταν το \textit{audio\_data}
συμπληρώσει $1024$ bytes, θα στείλουμε το πρώτο πακέτο το οποίο θα περιέχει τα πρώτα $1024$ bytes
του \textit{audio\_data}. Όταν συμπληρώσει $2*1024 = 2048$ bytes, θα στείλουμε $1024$ bytes με
offset $1*1024$ bytes από την αρχή του \textit{audio\_data}. Όμοια στα  $3*1024 = 3072$ bytes
θα στείλουμε $1024$ bytes με offset $2*1024$ bytes από την αρχή του \textit{audio\_data} κλπ.

Όταν το κουμπί Call πατηθεί όσο η κλήση βρίσκεται σε εξέλιξη φροντίζουμε να κλείσουμε τα TargetDataLine
και DatagramSocket μας για να μην έχουμε resource leaks. Υποθέτουμε ότι οι κλήσεις χρησιμοποιώντας 
αυτήν την εφαρμογή θα έχουν διάρκεια μερικών λεπτών, καθώς αφήνουμε το \textit{out} να μεγαλώνει 
ανεξέλεγκτα. Θεωρητικά αν περάσει επαρκής χρόνος τα \textit{out} και \textit{audio\_data} θα γίνουν 
τόσο μεγάλα ώστε να καταλάβουν όλη τη μνήμη του συστήματος (και λογικά θα τερματιστεί η εφαρμογή μας
από το λειτουργικό σύστημα του υπολογιστή στον οποίο τρέχει).


\subsection{Παράδειγμα VoIP μέσω Wireshark}
\section{Συμπεράσματα;}
Χρειάζεται αυτό το section; Ο Τσακ Νόρις είπε ``έλα μου ντε'' και ο Ντε ήρθε\ldots
\end{document}
